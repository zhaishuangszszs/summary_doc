[toc]
# <center>c++Doc</center>
#### 构造析构函数坑点
+ 删除析构函数 
```
class Test{
public:
    Test(){
        a=10;
    }
    int a;
    ~Test()=delete;
};
```
如果尝试创建一个局部对象
`Test test`
编译器会报错。
`Test* test=new Test;`
编译器可以通过
`delete test;`
`delete`会调用Test的析构函数因此编译器报错。
**总结**：
删除析构函数,使得Test类只能在**堆中分配**,并且无法被销毁。
禁止类的用户在 __栈中创建Test类的对象__,阻止用户销毁对象。
只创建，不销毁，可以用在内存池等系统自己管理的资源，程序退出前手动清理。
## 多线程编程
#### 主线程退出子线程是否运行？
> * 主线程(`main`)`return`或者`exit`方式退出，进程结束，子线程退出。（主线程的return会调用exit）
> * 主线程`thread_exit()`方式退出子线程继续运行。当所有线程执行完毕，进程才会退出。
> * 子线程崩溃，主线程也必定崩溃。子线程崩溃产生信号除非故意拦截，否则进程死掉，主线程也不会存在。
## C++字符串操作函数
### 字符操作
#### 判断是否为字符或者数字
> 头文件：`cctype` 
函数：isalnum()
功能：判断一个字符是否是字母或者（十进制）数字，若为字母或者数字，则返回True(非0值)，否者返回False(0)。
#### 字符大写小写转换
> 头文件：cctype
函数：tolower(),toupper()
功能：实现字母的大小写转换
#### 字符串数字互转
> 头文件：`#include<cstring>` 
string -> int :`stoi()`
#### c++中string,char*,const char*互转



## 坑点
### 1.全局变量，static变量
#### 初始化
> 全局变量、文件域中的静态变量、类中的成员静态变量在**main函数执行前初始化**；局部变量中的静态变量在**第一次调用时初始化**。

* C和C++的区别：**局部静态变量：**
> 在C语言中是编译期初始化并分配内存，故不能用变量给静态局部变量赋值，只能用常量。
在C++中是第一次执行时初始化，因为C++引入了对象的概念，对象一般需要构造函数，无法简单的分配内存，故可以用变量赋值，并且在第一次使用时初始化。

* 初始化又分为静态和动态：
> **静态初始化**：

针对用常量来对全局变量进行初始化的情况，这个变量是简单的内置类型（**不包括含构造函数的复杂类**，归属于下一项）。例如这里的a变量。
```
int a = 3;
class A{
};
```
> **动态初始化（运行期）**（main函数前，局部静态变量除外（讨论不含局部变量，在栈中肯定main函数后））：
1. 需要经过函数调用来完成的初始化。例如这里的a变量。
`int a = foo()`
2. 复杂类型的初始化。需要调用构造函数。例如这里的aa变量。
```
Class A{
    A(){}
}
A aa;
```
#### 类的静态成员变量声明和定义
使用过类中的静态成员变量的伙伴都发现了，在类中定义的静态成员变量，还必须要在类外定义下才可以使用，否则会编译报错。

> 那么为什么会出现这种情况呢？

静态成员变量不属于任何一个对象，对象的数据中不应该包含静态成员的数据。所以在定义类的时候不会给静态变量分配内存只是声明，因此就要在其他地方分配即定义。
> 定义与声明的区别：

**声明**：只是向程序表面变量的类型和名字。
**定义**：为变量分配内存，也可以顺便初始化。程序中变量有且只有一个定义（更能说明为什么要在类外再定义下类的静态成员变量了）。
#### 初始化顺序(坑点)
* 对于编译单元（同一个文件）的全局变量来讲，初始化顺序跟声明的顺序一致。销毁顺序则相反。
* 对于不同编译单元的全局变量，初始化顺序不确定。对于不同编译单元的全局变量互相引用的情况应避免。
