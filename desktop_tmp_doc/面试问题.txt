1.多线程加锁的基本原则？
（1）多线程、进程并行访问共享资源时，一定要加锁保护 
（2）锁的职责单一 （才能范围小）
（3）锁范围尽量小，只锁对应资源操作代码 
（4）避免嵌套加锁如果必须加锁，务必保证不同地方的加锁顺序是一样的 
建议
进程间通讯，使用自己保证互斥的数据库系统、共享内存，或socket消息机制；尽量避免使 用文件等进程无法管理的资源 
可重入函数尽量只使用局部变量和函数参数，少用全局变量、静态变量
锁中避免调用函数；如果必须调用函数，务必保证不会造成死锁 
锁中避免使用跳转语句 

2.float，double判断相等？
两个浮点数的差的绝对值 小于一个很小的数时 就把它们视作是相等的。


3.死锁的产生具体自己代码？



4.进程间和线程的区别（堆栈）？
（进程本质是程序运行，线程本质是函数运行）

进程：
是计算机中资源分配基本单位。
线程：
是在进程内部创建和管理的执行单位。由于线程运行的本质就是函数运行，函数运行时信息是保存在栈帧中的，因此每个线程都有自己独立的、私有的栈区。

进程拥有独立的地址空间、文件描述符、打开的文件等资源。（所以进程间通信比较麻烦）
线程共享同一个进程的资源。

创建和销毁进程的开销通常比创建和销毁线程的开销更大。
进程切换时，消耗的资源大，效率低。所以涉及到频繁的切换时，使用线程要好于进程。
同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。

线程是处理器调度的基本单位，但是进程不是。

对资源的管理和保护要求高，不限制开销和效率时，使用多进程。
要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。

协程：
是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。


5进程间通信方式？
管道、共享内存、信号量（用于同步）、消息队列、套接字


6线程安全？
（学习内核级线程用户级线程）
在一般情况下，子线程是无法直接访问主线程的局部变量的。这是因为每个线程都有自己的栈空间，局部变量是存储在线程的栈帧中的，不同线程之间的栈是相互独立的。
然而，可以通过一些手段使子线程能够访问主线程的局部变量：

参数传递：在创建子线程时，可以将主线程的局部变量作为参数传递给子线程的函数。这样子线程就可以通过函数参数来访问主线程的局部变量。

全局变量或共享变量：将需要在主线程和子线程之间共享的变量定义为全局变量或共享变量，使得所有线程都可以访问和修改这些变量。

对共享变量的访问需要进行适当的同步和互斥控制，以避免竞争条件和数据不一致的问题。线程安全的同步机制，如互斥锁（mutex）、信号量（semaphore）、条件变量（condition variable）等，可以用于确保多个线程对共享变量的安全访问。




7.树的时间复杂度
b树mlogmN

8.阻塞的时候不消耗cpu资源


9.static原理
未初始化的static在.bss字段初始化的在data字段
全局 static 变量的初始化在程序加载时进行。这意味着在程序启动期间，编译器会为全局 static 变量分配内存，并根据其定义的初始值对其进行初始化。
局部静态变量的内存空间位于静态数据区（Static Data Area）或全局数据区（Global Data Area），而不是存储在栈上。它们的初始化只会在第一次进入声明它们的函数时进行，之后的函数调用不会再次初始化。

10.构造函数的作用？
构造函数用于初始化类的对象。当创建类的对象时，构造函数会自动调用，为对象的成员变量赋初值，确保对象在创建后处于有效的状态。

函数中创建的对象是在运行时创建的，也就是在程序执行到包含对象创建代码的函数调用时才会创建这些对象。

11·全局变量创建初始化
全局变量（Global Variable）是在程序加载时创建并初始化的，其内存空间位于全局数据区（Global Data Area）或静态数据区（Static Data Area）。
对于没有显式初始化的全局变量，默认情况下会进行零初始化（Zero Initialization），即将其所有字节设置为0或对应类型的零值。如果在定义全局变量时指定了初始值，则会使用指定的初始值进行初始化。


12静态对象创建初始化

静态对象的初始化时间取决于其定义的上下文和存储位置。静态对象可以分为两种情况：静态局部变量和静态成员变量。

静态成员变量：静态成员变量是类的成员变量，由 static 关键字声明。静态成员变量的初始化通常在程序加载时进行，与全局变量类似。它们的初始化顺序与定义的顺序有关，先定义的静态成员变量先进行初始化。

静态局部变量：静态局部变量是在函数内部声明的静态变量。静态局部变量的初始化仅在第一次执行到定义它的语句时进行。例如，当函数被首次调用时，静态局部变量将被初始化，然后在后续函数调用中保持其值。

13extern作用
extern 是 C++ 中的关键字，用于声明一个全局变量或函数的外部链接。它的主要作用是在当前源文件中引用另一个源文件中定义的全局变量或函数。

14.thread_exit和return 退出
前者，main() 执行完 return 之后，实际上会调用 exit() 函数，该函数除了执行关闭IO等操作之外，还会执行关掉其他子线程的操作。

后者，在主线程中执行 pthread_exit() ，实际上是提前结束了 main 的主线程，也就无法执行后续的 exit() 函数了。所以，这种方法是可以达到主线程退出子线程继续运行的目的。


15.emplace和insert比，emplace直接传递参数调用构造函数，insert会产生临时对象，在拷贝进去。

poll,epoll
epoll poll原理
epoll边沿模式/水平模式

I/O密集型和cpu密集型任务选用线程池还是进程池？

三次握手四次挥手？

mmap
引用和指针的区别
数据库事务/引擎
top
stl源码剖析
map,unordermap,实现
git rebase/git merge

查看time_wait的命令

引用可以作对象成员吗，远程执行shell命令，

移动构造函数为什么能指向栈上局部变量(如果在栈上)
.c的联结方法，工程结构，makefile等问题

移动构造和拷贝构造能够访问变量的私有成员。



const用法：

const修饰的变量的存储位置

c语言中const全局变量存储在只读数据段，编译期最初将其保存在符号表中（const全局有的编译器直接当立即数存在ROM中），第一次使用时为其分配内存，在程序结束时释放。

而const局部变量（局部变量就是在函数中定义的一个const变量，）存储在栈中，代码块结束时释放。

在c语言中可以通过指针对const局部变量进行修改，而不可以对const全局变量进行修改。因为const全局变量是存储在只读数据段

而c++中，一个const不是必需创建内存空间，而在c中，一个const总是需要一块内存空间。

在c++中是否要为const全局变量分配内存空间，取决于这个const变量的用途，如果是充当着一个值替换（即就是将一个变量名替换为一个值），那么就不分配内存空间，不过当对这个const全局变量取地址或者使用extern时，会分配内存，存储在只读数据段。也是不能修改的。

c++中对于局部的const变量要区别对待：

对于基础数据类型，也就是const int a = 10这种，编译器会把它放到符号表中，不分配内存，当对其取地址时，会分配内存
对于基础数据类型，如果用一个变量初始化const变量，如果const int a = b,那么也是会给a分配内存
对于自定数据类型，比如类对象，那么也会分配内存。

c中const默认为外部连接，c++中const默认为内部连接.当c语言两个文件中都有const int a的时候，编译器会报重定义的错误。而在c++中，则不会，因为c++中的const默认是内部连接的。如果想让c++中的const具有外部连接，必须显示声明为: extern const int a = 10。

c++总结const
1、const修饰的量不是常量，仅仅是个只读量。在编译的时候全部替换const变量被赋予的值（这点和C语言的宏相似），在运行的时候该const变量可通过内存进行修改:

1.1）通过内存(指针)可以修改位于栈区的const变量，语法合乎规定，编译运行不会报错，但是在编译的时候所有用到该常量的地方全部被替换成了定义时所赋予的值，然后再运行的时候无法使用通过指针修改后的值。
1.2）通过内存(指针)修改位于静态存储区的的const变量，语法上没有报错，编译不会出错，一旦运行就会报告异常。

注：通过指针修改在全局区上的const变量，编译可通过，运行就会报异常。


