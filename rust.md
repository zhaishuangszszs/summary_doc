[toc]
# <center>rustdoc</center>

## 通用编程概念
### 命名风格
**函数和变量名**：Rust 代码中的函数和变量名使用下划线命名法（snake case，直译为蛇形命名法）规范风格。在下划线命名法中，所有字母都是小写并使用下划线分隔单词。

### 函数
* Rust 不关心函数定义于何处，只要定义了就行。
* 在函数签名中，必须声明每个参数的类型。
### 闭包
**定义：**
* Rust 的 **闭包(closures)** 是可以保存在一个变量中或作为参数传递给其他函数的**匿名函数**。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许**捕获被定义时所在作用域中的值**。
* 闭包并不总是要求像 fn 函数那样在参数和返回值上注明类型。
 

### 数据类型
#### 字符类型
char 字面量采用单引号括起来，这与字符串字面量不同，字符串字面量是用双引号括起来。Rust 的字符类型大小为 4 个字节，表示的是一个 Unicode 标量值，这意味着它可以表示的远远不止是 ASCII。标音字母，中文/日文/韩文的文字，emoji，还有零宽空格(zero width space)在 Rust 中都是合法的字符类型。
#### 元组中单元类型
没有任何值的元组 () 是一种特殊的类型，只有一个值，也写成 ()。该类型被称为单元类型（unit type），该值被称为单元值（unit value）。如果表达式不返回任何其他值，就隐式地返回单元值。
#### 切片(slice)类型
* 另一个没有所有权的数据类型是 slice
> **字符串切片**
> * 减少使用无效索引的bug
> * 字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内

#### 字符串
* 函数参数类型 **`&str`可以接受`String，&str`类型参数** 。
* 定义一个获取字符串 slice 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能

**使用 + 运算符或 format! 宏拼接字符串**
 ```
#![allow(unused)]
fn main() {
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
}
```
*  &String 可以被 强转（coerced）成 &str
* **format!** 不会获取任何参数的所有权。
* Rust 的字符串不支持索引。
#### 结构体
**普通结构体：**
* 定义结构体，需要使用 struct 关键字并为整个结构体提供一个名字。结构体的名字需要描述它所组合的数据的意义。接着，在大括号中，定义每一部分**数据的名字**和**类型**，我们称为 字段（field）.

**元组结构体（tuple struct）:**
* 元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型

**单元结构体：**
* 没有任何字段的结构体，例如`struct AlwaysEqual;`,它们被称为类单元结构体（unit-like structs）
> 如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的
#### 枚举
* 用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据。

**option枚举** 
```
enum Option<T> {
    Some(T),
    None,
}
```
* 如果使用 None 而不是 Some，需要告诉 Rust Option<T> 是什么类型的，因为编译器只通过 None 值无法推断出 Some 成员保存的值的类型。
* **通配模式**和 **_ 占位符**
> **通配模式**最后一个分支则涵盖了所有其他可能的值，模式是我们命名为 other 的一个变量
**_ 占位符**使用 _ ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。这告诉 Rust 我们不会使用这个值，所以 Rust 也不会警告我们存在未使用的变量。

### 类型转换
Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 as 关键字进行显式类型转换（casting）。


### trait
#### trait作为参数
* 使用 trait 来接受多种不同类型的参数
* `impl trait`
#### trait bound
* rait bound 与泛型参数声明在一起，位于尖括号中的冒号后面。`pub fn notify<T: Summary>(item: &T){}`
* `impl Trait` 很方便，适用于短小的例子。更长的 `trait bound` 则适用于更复杂的场景。
> * `pub fn notify(item: &(impl Summary + Display)) {}
`
> * `pub fn notify<T: Summary + Display>(item: &T) {}
` 
#### 返回trait类型
* `fn returns_summarizable() -> impl Summary{}`。不过这只适用于返回单一类型的情况
* **trait对象**解决返回不同类型的情况

### 迭代器
* 虽然在 Rust 中我们很少会需要注明类型，然而 `collect` 是一个经常需要**注明类型**的函数，因为 Rust 不能推断出你想要什么类型的集合。

## 返回值处理
### 传播错误
* ? 运算符只能被用于返回值与 ? 作用的值相兼容的函数。返回值不兼容的 main 函数中使用 ? 运算符会得到错误。
* 修改 main 返回 Result<(), E> 允许对 Result 值使用 ? 运算符

### 表示式和语句
*  Rust 是一门基于表达式（expression-based）的语言
> * **语句**（Statements）是执行一些操作但不返回值的指令。
**表达式**（Expressions）计算并产生一个值。
* 函数定义也是语句，但大部分函数隐式返回最后一个表达式。
* {} 也是一个表达式

## 所有权
**所有权规则**：
* Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
* 值在任一时刻有且只有一个所有者。
* 当所有者（变量）离开作用域，这个值将被丢弃。
* 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。
**引用**：
* 注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。
* 两个可变引用的代码将会失败：
**循环**
* for循环会转移所有权
**可变性**
当所有权转移时，数据的可变性可能发生改变。


### Rc和Arc
Rc的clone只**克隆栈上的指针**，并且引用计数加一。
**Rc**是不可变引用。
* Rc/Arc 是不可变引用，你无法修改它指向的值，只能进行读取，如果要修改，需要配合后面章节的内部可变性 RefCell 或互斥锁 Mutex
### Cell和RefCell
*  Rust 提供了 Cell 和 RefCell 用于内部可变性，简而言之，可以在拥有不可变引用的同时修改目标数据。
* 对于正常的代码实现来说，这个是不可能做到的（要么一个可变借用，要么多个不可变借用）。
* Cell 类型针对的是**实现了 Copy 特征的值类型**


## 输出格式
* println! 宏能处理很多类型的格式，不过，{} 默认告诉 println! 使用被称为 Display 的格式：意在提供给直接终端用户查看的输出。目前为止见过的基本类型都默认实现了 Display
* **dbg! 宏**。dbg! 宏**接收**一个表达式的**所有权**打印出代码中调用 dbg! 宏时所在的文件和行号，以及该表达式的结果值，并**返回该值的所有权**。
### Deref
> *  **表达式中**，我们无法自动隐式地执行 Deref 解引用操作。`let a=b+1 != let a=*b+1`，需要显示解引用。
> * **方法调用**会自动解引用
> **打印输出**也会自动解引用。
## 智能指针
> * 对于 Rust 而言，不允许显式地调用析构函数如`a.drop()`,但可以调用`drop(a)`

> **Drop顺序**
**变量级别**，按照逆序的方式
**结构体内部**，按照顺序的方式

> * **Copy 和 Drop互斥**，实现了 Copy 的类型无法拥有析构函数。
> * 任何不需要分配内存或某种形式资源的类型都可以实现 Copy
* 元组Copy类型，当且仅当其包含的类型也都实现 Copy 的时候。

> * 事实上，Rc<T> 是指向底层数据的不可变的引用，因此你无法通过它来修改数据。

## 递归类型
### 枚举递归
```
enum List {
    Cons(i32, List),
    Nil,
}
```
编译时无法知道具体的大小,rust报错
```
enum List {
    Cons(i32, Box<List>), //DST动态大小
    Nil,
}

```
这样便解决了.  

## 项目管理
* 当使用 use 关键字将名称导入作用域时，在新作用域中可用的名称是私有的。

## 多线程并发编程
### 多线程使用

**注意**：

> * `main`线程一旦结束，程序就立刻结束，未完成的子线程也会结束。
> * 通过调用 `[thread_handle].join`，可以让当前线程阻塞，直到它等待的子线程的结束。
> * `Rust` 的线程模型是 1:1 模型
> * `rust`没有直接杀掉线程的`api`。线程执行完结束(或者main线程结束)。 


#### 内部可变性
`Rc<T>`和`RefCell<T>`的结合，可以实现单线程的内部可变性。
`Mutex<T>`可以支持修改内部数据，当结合`Arc<T>`一起使用时，可以实现多线程的内部可变性。


#### cpu密集型任务
> * 据不精确估算，创建一个线程大概需要 0.24 毫秒，随着线程的变多，这个值会变得更大，因此线程的创建耗时是不可忽略的，只有当真的需要处理一个值得用线程去处理的任务时，才使用线程，一些鸡毛蒜皮的任务，就无需创建线程了。
> * 因为 CPU 的核心数限制，当任务是 CPU 密集型时，就算线程数超过了 CPU 核心数，也并不能帮你获得更好的性能，因为每个线程的任务都可以轻松让 CPU 的某个核心跑满，既然如此，让线程数等于 CPU 核心数是最好的。
> * 但是当你的任务大部分时间都处于阻塞状态时，就可以考虑增多线程数量，这样当某个线程处于阻塞状态时，会被切走，进而运行其它的线程，典型就是网络 IO 操作。但是事实上，对于这种网络 IO 情况，一般都不再使用多线程的方式了，毕竟操作系统的线程数是有限的，意味着并发数也很容易达到上限，而且过多的线程也会导致线程上下文切换的代价过大，使用 async/await 的 M:N 并发模型，就没有这个烦恼。

### 线程同步
##### 消息传递
> * 异步通道的缓冲上限取决于你的内存大小，不要撑爆就行。

### 线程异步
* 在`async fn`函数中使用`.await`可以等待另一个异步调用的完成。但是与`block_on`不同，`.await`并不会阻塞当前的线程，而是异步的等待`Future A`的完成，在等待的过程中，该线程还可以继续执行其它的`Future B`，最终实现了并发处理的效果

## 语法糖
### rust中的&和ref
[ref和&的异同](https://blog.csdn.net/quicmous/article/details/120489008)


### 关联类型


## 遇到的坑

* **零成本抽象**：一段代码抽象出一个抽象的框架，之后实现这个框架适应不同情况，但没有增加额外的成本就叫零成本抽象。

### **1.数据不可变变为可变**
* 当所有权转移时，数据的可变性可能发生改变。[一般定义变量默认不可变，但转移所有权时可以重新变为可变变量。]
```
let a=String::from("hello");
let mut b=a;//成立，函数参数传递如果转移所有权也成立
```
### **2.clone和copy**
**引用类型的Copy和Clone**
* 没有实现Clone时，引用类型的clone()将等价于Copy（**浅拷贝***）
* 实现了Clone时，引用类型的clone()将克隆并得到引用所指向的类型(**深拷贝一份数据**)
* 借用规则的一个推论是当有一个不可变值时，不能可变地借用它。
* copy和drop互斥

### **3.切片类型**
* 在 Rust 中，所有的切片都是动态大小类型，它们都**无法直接被使用**。
* 切片只能**通过引用来使用**。
```
let a:[i32;3]=[1,2,3] //是数组类型
let b:&[i32;3]=&a; //是数组引用类型
let c:[i32]=a[..]; //是切片类型，无法被直接使用，编译报错 
let d:&[i32]=b[..]; //切片类型

let a:&str="hello"; //字符串字面值,编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件中,所以只能不可变引用
let a:str="hello"; //切片类型，编译报错，无法使用
let c:&str=&String::from("hello"); //切片类型【这个不加注解是&String类型4中有解释】
```

### **4.隐式Deref转换**
* **前提：** String在rust中算智能指针。
* Deref 可以支持连续的隐式转换，直到找到适合的形式为止
```
fn main(){
    let s=Box::new(String::from("hello"));
    display(&s);// 注意传入借用，函数参数为借用，不转移所有权
}
fn display(s:&str){
    println!("{}",s);
}
```
首先 Box 被 Deref 成 String 类型，结果并不能满足 display 函数参数的要求，编译器发现 **String 还可以继续 Deref 成 &str**，最终成功的匹配了函数参数。
**注：**
* 方法中参数为切片引用，传入引用可以Deref

### **5.self和Self**
* **self**表示调用方法的**对象**，作为类方法的第一个参数，类似于C++中的this。
* **Self**表示调用者的**类型**。
* **self**作函数的第一个参数时它等价于**self: Self**。
* 方法参数中的Self是一种语法糖，是**方法的接收类型**（例如，本方法所在的impl的类型，**impl后面跟着的类型**）。
它可能出现在**trait**或**impl**中。但经常出现在trait中，它是任何最终实现trait的类型代替（在定义trait时未知该类型）。

### **6.String和str**
* String 是一个 `Vec<u8>` 的封装。
* **String和str都是UTF-8 编码**。尝试使用索引语法访问 String 的一部分，会出现一个错误。
  **遍历字符串的方法**
    1. 调用 `chars` 方法
    2. 调用 `bytes` 方法
### 7.自动解引用
[网上部分总结](https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules)
**个人总结**
* println!自动解引用
* 方法调用（即用点调用）
* 方法参数是引用，传递的类型也要是引用之后可以自动解引用(本质类型转换时解引用)
* 类型转换时
```
let my_string = String::from("Rust");
let my_box = Box::new(my_string);
let my_ref: &str = &my_box; // 链式解引用
```

### 8 lib.rs和main.rs关系
* 没有mian.rs说明是一个**库package**,crate指的就是**lib.rs**。
两个同时存在，说明同时存在两个crate相互独立，同时编译。`mian.rs`中的**crate**指的就是`main.rs`**自己**binary crate。`lib.rs`中指的就是`lib.rs`**自己**library crate。
* main.rs想**使用lib.rs中定义的结构**需要`use package（名字）::<lib.rs中的结构>`，**但是main.rs不是lib.rs的子模块因此，lib.rs模块是pub时才能用**。
* 想要mian.rs**使用lib.rs中的结构**，Cargo.tml中加入lib。同样只能引用pub模块
```
[lib]
name="项目名"//注意不能有连字符等
```
### 9 closure
* 尝试调用一个被推断为两个不同类型的闭包出错
* 函数指针实现了所有三个闭包 trait（Fn、FnMut 和 FnOnce），所以总是可以在调用期望闭包的函数时传递函数指针作为参数。
* 不同于闭包，fn 是一个类型而不是一个 trait
* 闭包表现为 trait，这意味着不能直接返回闭包。对于大部分需要返回 trait 的情况，可以使用实现了期望返回的 trait 的具体类型来替代函数的返回值。但是这不能用于闭包，因为它们没有一个可返回的具体类型；例如不允许使用函数指针 fn 作为返回值类型。
可以使用 trait 对象解决。
```
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```
### 10. From&Into
[From&Into](https://rustwiki.org/zh-CN/rust-by-example/conversion/from_into.html)

### 11 Mutex
* Mutex 结构体没有公有 unlock 方法，因为锁的所有权依赖 lock 方法返回的 LockResult<MutexGuard<T>> 中 MutexGuard<T> 的生命周期。

### 12 mpsv
* 标准库提供了通道std::sync::mpsc，其中mpsc是multiple producer, single consumer的缩写，代表了该通道**支持多个发送者**，但是**只支持唯一的接收者**。
* `mpsc::channel`创建的通道是**异步通道**。
* `mpsc::sync_channel(0)`同步通道发送消息是阻塞的，只有在消息被接收后才解除阻塞
* **同步通道缓存变多**也**和异步通道效果相同**
* **所有发送者被drop**或者**所有接收者被drop**后，通道会自动关闭。
* 事实上**异步通道的缓冲上限**取决于你的**内存大小**，不要撑爆就行。